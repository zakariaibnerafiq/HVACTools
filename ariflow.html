<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AirFlow Designer - Utility Hub</title>
    <link rel="stylesheet" href="assets/fonts.css" />
    <script src="assets/tailwindcss.js"></script>
    <script src="assets/vue.global.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        bg: "#0d0d0d",
                        "border-low": "#1a1614",
                        "border-med": "#2d2621",
                        "text-main": "#f4f4f4",
                        "text-muted": "#6b5c54",
                        "sunset-glow": "#ff8c42",
                        "sunset-dim": "#4a3728",
                    },
                    fontFamily: {
                        sans: ["Inter", "sans-serif"],
                        mono: ["Roboto Mono", "monospace"],
                    },
                },
            },
        };
    </script>
    <style>
        [v-cloak] {
            display: none;
        }

        canvas {
            background-color: #0d0d0d;
            cursor: crosshair;
        }

        .tool-group {
            display: flex;
            flex-direction: row;
            gap: 4px;
            background: transparent;
            padding: 0;
            border-radius: 0;
            flex-wrap: wrap;
        }

        .tool-btn {
            @apply px-3 py-2 text-[10px] uppercase tracking-wider transition-all duration-100 border border-transparent rounded-sm;
            background: #0d0d0d;
            color: #6b5c54;
        }

        .tool-btn:hover {
            @apply bg-[#1a1614] text-white border-border-low;
        }

        .tool-btn-active {
            @apply bg-[#1f1b19] text-sunset-glow border-border-med shadow-inner;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tool-btn-inactive {
            @apply text-text-muted;
        }
    </style>
</head>

<body class="min-h-screen font-sans bg-bg text-text-main m-0 antialiased">
    <div id="app" v-cloak class="h-screen flex flex-col relative overflow-hidden">
        <!-- Floating Toolbar -->
        <div
            class="absolute top-6 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-1 bg-[#0d0d0d]/90 backdrop-blur-md border border-border-low rounded-lg p-1 shadow-2xl">
            <button v-for="t in tools" :key="t.id" @click="setTool(t.id)"
                :class="mode === t.id ? 'bg-[#1a1614] text-sunset-glow shadow-inner' : 'text-text-muted hover:text-white hover:bg-[#1a1614]/50'"
                class="p-2 rounded-md transition-all duration-200 group relative" :title="t.label">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <!-- Icons based on tool ID -->
                    <path v-if="t.id === 'select'" d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" />
                    <path v-if="t.id === 'select'" d="M13 13l6 6" />

                    <path v-if="t.id === 'move'" d="M9 5l3-3 3 3M5 9l-3 3 3 3M9 19l3 3 3-3M19 9l3 3-3 3" />
                    <path v-if="t.id === 'move'" d="M12 2v20M2 12h20" />

                    <rect v-if="t.id === 'terminal'" x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <path v-if="t.id === 'terminal'" d="M9 12h6m-3-3v6" />

                    <circle v-if="t.id === 'branch'" cx="12" cy="12" r="10" />
                    <path v-if="t.id === 'branch'" d="M12 8v8m-4-4h8" />

                    <circle v-if="t.id === 'duct'" cx="12" cy="12" r="3" />
                    <path v-if="t.id === 'duct'" d="M5 5l14 14" />

                    <path v-if="t.id === 'flip'" d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" />
                    <path v-if="t.id === 'flip'" d="M16 6l-4-4-4 4" />
                    <path v-if="t.id === 'flip'" d="M12 2v13" />
                    <rect v-if="t.id === 'image'" x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <circle v-if="t.id === 'image'" cx="8.5" cy="8.5" r="1.5" />
                    <polyline v-if="t.id === 'image'" points="21 15 16 10 5 21" />
                </svg>
            </button>
        </div>

        <header class="border-b border-border-low p-5 bg-[#0d0d0d] flex justify-between items-center z-10">
            <div class="flex items-center gap-3">
                <div class="w-2 h-2 bg-sunset-glow rounded-full"></div>
                <h1 class="text-lg font-medium tracking-tighter text-white uppercase">
                    AirFlow Designer
                </h1>
                <div class="w-px h-4 bg-border-low mx-2"></div>

                <!-- View Controls -->
                <div class="flex items-center gap-2">
                    <button @click="resetView"
                        class="px-2 py-1 text-[10px] uppercase tracking-wider text-text-muted hover:text-white border border-transparent hover:border-border-low rounded transition-all"
                        title="Reset Zoom & Pan">
                        Reset View
                    </button>
                    <label class="flex items-center gap-2 cursor-pointer group">
                        <div class="relative">
                            <input type="checkbox" v-model="snapToGrid" class="peer sr-only">
                            <div
                                class="w-8 h-4 bg-[#1a1614] rounded-full peer-checked:bg-sunset-glow/20 transition-all">
                            </div>
                            <div
                                class="absolute left-0 top-0 w-4 h-4 bg-text-muted rounded-full peer-checked:bg-sunset-glow peer-checked:translate-x-full transition-all scale-75">
                            </div>
                        </div>
                        <span
                            class="text-[10px] uppercase tracking-wider text-text-muted group-hover:text-white transition-colors">Snap
                            Grid</span>
                    </label>
                </div>
            </div>
            <a href="index.html"
                class="text-text-muted hover:text-sunset-glow transition-colors text-xs uppercase tracking-wider flex items-center gap-2">
                <span>&larr;</span> Back to Home
            </a>
        </header>

        <main class="flex-1 flex overflow-hidden relative">
            <!-- Canvas Area -->
            <div class="flex-1 relative bg-[#090909] cursor-crosshair overflow-hidden min-w-0" @mousemove="updateMouse"
                @mousedown.prevent="handleCanvasClick" @mouseup="handleMouseUp" @wheel.prevent="handleWheel">
                <canvas ref="canvasRef" :width="canvasWidth" :height="canvasHeight" class="block"></canvas>

                <div
                    class="absolute bottom-6 left-6 text-[10px] text-text-muted tracking-widest uppercase opacity-50 pointer-events-none font-mono">
                    {{ mode }} mode | <span v-if="mouseWorld">W: {{ Math.round(mouseWorld.x) }}, {{
                        Math.round(mouseWorld.y)
                        }}</span> | Drag: {{ draggingNode !== null ? draggingNode : 'None' }}
                </div>
            </div>

            <!-- Properties Sidebar -->
            <div class="w-[280px] bg-[#0d0d0d] border-l border-border-low flex flex-col z-20 h-full shrink-0">
                <div class="p-6 border-b border-border-low">
                    <div v-if="selectedNodes.size > 0 || selectedEdges.size > 0" class="mb-4">
                        <div class="text-sunset-glow text-sm font-mono mb-2">
                            <span v-if="selectedNodes.size === 1">
                                {{ nodes[Array.from(selectedNodes)[0]].type === 'terminal' ? 'Terminal' : 'Junction' }}
                                #{{
                                Array.from(selectedNodes)[0] }}
                            </span>
                            <span v-else-if="selectedNodes.size > 1">
                                {{ selectedNodes.size }} Nodes Selected
                            </span>
                            <span v-if="selectedEdges.size > 0">
                                <span v-if="selectedNodes.size > 0">, </span>
                                {{ selectedEdges.size }} Ducts Selected
                            </span>
                        </div>
                        <button @click="deleteSelected"
                            class="w-full py-1 px-2 mb-2 text-[10px] uppercase tracking-wider border border-red-900/50 text-red-500 hover:bg-red-900/20 transition-all rounded-sm flex items-center justify-center gap-2">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path
                                    d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                                </path>
                            </svg>
                            Delete Selection
                        </button>
                    </div>
                    <div v-else class="text-text-muted italic text-sm">
                        No selection
                    </div>
                </div>

                <div class="p-6 flex-1 overflow-y-auto min-h-0">
                    <!-- Multiple Terminals Selected -->
                    <div v-if="selectedNodes.size > 1 && allSelectedAreTerminals" class="space-y-6">
                        <div class="text-sunset-glow text-sm font-mono mb-2">
                            {{ selectedNodes.size }} Terminals Selected
                        </div>
                        <div>
                            <label class="text-[10px] text-text-muted uppercase tracking-widest block mb-1">Bulk Airflow
                                (CFM)</label>
                            <input type="number" v-model="bulkCfm" placeholder="Enter CFM"
                                class="w-full bg-[#12100e] border border-border-med p-3 text-text-main outline-none text-right font-mono focus:border-sunset-glow focus:shadow-[0_0_15px_rgba(255,140,66,0.1)] transition-all mb-2" />
                            <button @click="applyBulkCfm"
                                class="w-full py-2 text-[10px] uppercase tracking-wider bg-sunset-glow text-bg hover:brightness-110 transition-all rounded-sm font-bold">
                                Apply to All
                            </button>
                            <p class="text-[9px] text-text-muted mt-2">Apply the same CFM value to all selected
                                terminals</p>
                        </div>
                    </div>

                    <!-- Single Node Properties -->
                    <div v-else-if="singleSelectedNode !== null && nodes[singleSelectedNode]" class="space-y-6">
                        <!-- Terminal Properties -->
                        <div v-if="nodes[singleSelectedNode].type === 'terminal'" class="space-y-3">
                            <div>
                                <label class="text-[10px] text-text-muted uppercase tracking-widest block">Airflow
                                    (CFM)</label>
                                <input type="number" v-model.number="nodes[singleSelectedNode].cfm"
                                    @input="recalcAndRender"
                                    class="w-full bg-[#12100e] border border-border-med p-3 text-text-main outline-none text-right font-mono focus:border-sunset-glow focus:shadow-[0_0_15px_rgba(255,140,66,0.1)] transition-all" />
                            </div>
                        </div>

                        <div v-if="nodes[singleSelectedNode].type === 'branch'" class="text-xs text-text-muted">
                            Junctions do not have modifiable properties. Connect ducts to
                            route flow.
                        </div>
                    </div>

                    <!-- Edge Properties -->
                    <div v-else-if="singleSelectedEdge !== null && edges[singleSelectedEdge]" class="space-y-6">
                        <div class="text-sunset-glow text-sm font-mono mb-2">
                            Duct Segment #{{ singleSelectedEdge }}
                        </div>

                        <div>
                            <label class="text-[10px] text-text-muted uppercase tracking-widest block mb-1">Flow
                                Rate</label>
                            <div class="text-lg font-mono text-text-main">{{ edges[singleSelectedEdge].flow }} CFM</div>
                        </div>

                        <div class="border-t border-border-med pt-4">
                            <label class="flex items-center gap-2 cursor-pointer mb-4">
                                <input type="checkbox" v-model="edges[singleSelectedEdge].isCustom" @change="() => {
                      // Init dimensions if enabling
                      const idx = singleSelectedEdge;
                      if(edges[idx].isCustom && edges[idx].ductSize) {
                         const parts = edges[idx].ductSize.split('x');
                         if(parts.length === 2) {
                           edges[idx].customWidth = parts[0];
                           edges[idx].customHeight = parts[1];
                         }
                      }
                      recalcAndRender();
                  }" class="accent-sunset-glow">
                                <span class="text-[10px] text-text-muted uppercase tracking-widest">Manual Size
                                    Override</span>
                            </label>

                            <div v-if="edges[singleSelectedEdge].isCustom" class="space-y-3 mt-3">
                                <!-- Head Loss Input for Calculation -->
                                <div>
                                    <label class="text-[9px] text-text-muted block mb-1">Target Head Loss
                                        (in.WC/100ft)</label>
                                    <input type="number" v-model.number="targetHeadLoss" step="0.01"
                                        class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none text-right">
                                </div>

                                <div class="grid grid-cols-2 gap-2">
                                    <div>
                                        <label class="text-[9px] text-text-muted block mb-1">Width</label>
                                        <div class="flex flex-col gap-1">
                                            <input type="number" v-model="edges[singleSelectedEdge].customWidth" @input="() => {
                                 const idx = singleSelectedEdge;
                                 edges[idx].customSize = `${edges[idx].customWidth||0}x${edges[idx].customHeight||0}`;
                                 recalcAndRender();
                              }" class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none">
                                            <button @click="calculateDuctDimension(singleSelectedEdge, 'width')"
                                                title="Calculate Width from Height"
                                                class="text-[9px] uppercase tracking-wider bg-[#1a1614] hover:bg-[#2d2621] text-sunset-glow py-1 px-2 rounded-sm border border-border-med transition-colors">
                                                Suggest
                                            </button>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-[9px] text-text-muted block mb-1">Height</label>
                                        <div class="flex flex-col gap-1">
                                            <input type="number" v-model="edges[singleSelectedEdge].customHeight"
                                                @input="() => {
                                 const idx = singleSelectedEdge;
                                 edges[idx].customSize = `${edges[idx].customWidth||0}x${edges[idx].customHeight||0}`;
                                 recalcAndRender();
                              }" class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none">
                                            <button @click="calculateDuctDimension(singleSelectedEdge, 'height')"
                                                title="Calculate Height from Width"
                                                class="text-[9px] uppercase tracking-wider bg-[#1a1614] hover:bg-[#2d2621] text-sunset-glow py-1 px-2 rounded-sm border border-border-med transition-colors">
                                                Suggest
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Background Image Properties -->
                    <div v-else-if="mode === 'image'" class="space-y-6">
                        <h3 class="text-sunset-glow text-sm font-mono mb-2">Background Image</h3>

                        <div v-if="!backgroundImage">
                            <p class="text-xs text-text-muted mb-4">No image loaded.</p>
                            <button @click="triggerImageUpload"
                                class="w-full py-2 text-[10px] uppercase tracking-widest bg-[#12100e] border border-sunset-glow text-sunset-glow hover:bg-sunset-glow/10 transition-all rounded-sm">
                                Upload Image
                            </button>
                            <input type="file" id="bgImageInput" accept="image/*" class="hidden"
                                @change="handleImageUpload">
                        </div>

                        <div v-else class="space-y-4">
                            <div>
                                <label
                                    class="text-[10px] text-text-muted uppercase tracking-widest block mb-1">Opacity</label>
                                <input type="range" min="0" max="1" step="0.05" v-model.number="backgroundImage.opacity"
                                    @input="recalcAndRender" class="w-full accent-sunset-glow">
                                <div class="text-right text-xs font-mono text-text-muted">{{
                                    Math.round(backgroundImage.opacity * 100)
                                    }}%</div>
                            </div>

                            <div>
                                <label
                                    class="text-[10px] text-text-muted uppercase tracking-widest block mb-1">Scale</label>
                                <input type="number" step="0.1" v-model.number="backgroundImage.scale"
                                    @input="recalcAndRender"
                                    class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none">
                            </div>

                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="text-[9px] text-text-muted block mb-1">X Pos</label>
                                    <input type="number" v-model.number="backgroundImage.x" @input="recalcAndRender"
                                        class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none">
                                </div>
                                <div>
                                    <label class="text-[9px] text-text-muted block mb-1">Y Pos</label>
                                    <input type="number" v-model.number="backgroundImage.y" @input="recalcAndRender"
                                        class="w-full bg-[#12100e] border border-border-med p-2 text-text-main font-mono text-sm focus:border-sunset-glow outline-none">
                                </div>
                            </div>

                            <div class="pt-4 border-t border-border-med">
                                <button @click="deleteImage"
                                    class="w-full py-2 text-[10px] uppercase tracking-widest border border-red-900/50 text-red-500 hover:bg-red-900/20 transition-all rounded-sm">
                                    Remove Image
                                </button>
                            </div>

                            <!-- Keep hidden input for re-upload if needed, or just let them delete first -->
                        </div>
                    </div>

                    <div v-else class="text-center mt-10">
                        <div
                            class="w-8 h-8 rounded-full border border-border-med flex items-center justify-center mx-auto mb-3 text-border-med">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M20 6L9 17l-5-5" />
                            </svg>
                        </div>
                        <p class="text-xs text-text-muted">
                            Select a terminal to edits its CFM value.<br>
                            Select a duct to override size.<br>
                            Shift+Click to select multiple.
                        </p>
                    </div>
                </div>

                <div class="p-6 border-t border-border-low space-y-3 bg-[#0a0a0a]">
                    <div class="space-y-3 mb-6">
                        <label class="text-[10px] text-text-muted uppercase tracking-widest block">New Terminal
                            CFM</label>
                        <input type="number" v-model.number="defaultCfm"
                            class="w-full bg-[#12100e] border border-border-med p-2 text-text-muted text-sm outline-none text-right font-mono focus:border-border-low focus:text-text-main transition-all" />
                    </div>
                    <button @click="undo" :disabled="history.length === 0"
                        class="w-full py-3 text-[10px] uppercase tracking-widest bg-[#12100e] border border-border-med text-text-muted hover:text-white hover:border-text-muted disabled:opacity-20 transition-all rounded-sm">
                        Undo
                    </button>
                    <button @click="clearAll"
                        class="w-full py-3 text-[10px] uppercase tracking-widest bg-[#12100e] border border-red-900/30 text-red-800 hover:text-red-500 hover:border-red-500/50 transition-all rounded-sm">
                        Reset Canvas
                    </button>

                    <div class="grid grid-cols-2 gap-2 mt-4 pt-4 border-t border-border-low">
                        <button @click="exportJSON"
                            class="py-2 text-[10px] uppercase tracking-widest bg-[#12100e] border border-border-med text-text-muted hover:text-white hover:border-sunset-glow transition-all rounded-sm flex items-center justify-center gap-1">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Save
                        </button>
                        <button @click="triggerImport"
                            class="py-2 text-[10px] uppercase tracking-widest bg-[#12100e] border border-border-med text-text-muted hover:text-white hover:border-sunset-glow transition-all rounded-sm flex items-center justify-center gap-1">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            Load
                        </button>
                        <input type="file" id="importFile" accept=".json" class="hidden" @change="importJSON">
                    </div>

                    <!-- Load Sheet Section -->
                    <div class="mt-4 pt-4 border-t border-border-low space-y-3">
                        <h3 @click="isScheduleExpanded = !isScheduleExpanded"
                            class="text-[10px] text-text-muted uppercase tracking-widest flex items-center justify-between cursor-pointer hover:text-white transition-colors select-none">
                            <span>Duct Size Schedule</span>
                            <svg :class="{'rotate-180': isScheduleExpanded}" class="transition-transform duration-200"
                                width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </h3>

                        <!-- Collapsible Content -->
                        <div v-show="isScheduleExpanded" class="space-y-3">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="text-[9px] text-text-muted block mb-1">CFM Column</label>
                                    <input type="text" v-model="loadSheetColumns.cfmCol"
                                        class="w-full bg-[#12100e] border border-border-med px-2 py-1 text-text-muted text-xs outline-none font-mono focus:border-sunset-glow transition-all">
                                </div>
                                <div>
                                    <label class="text-[9px] text-text-muted block mb-1">Size Column</label>
                                    <input type="text" v-model="loadSheetColumns.sizeCol"
                                        class="w-full bg-[#12100e] border border-border-med px-2 py-1 text-text-muted text-xs outline-none font-mono focus:border-sunset-glow transition-all">
                                </div>
                            </div>

                            <div class="grid grid-cols-2 gap-2">
                                <button @click="triggerLoadSheetUpload"
                                    class="py-2 text-[10px] uppercase tracking-widest bg-[#12100e] border border-sunset-glow/50 text-sunset-glow hover:bg-sunset-glow/10 transition-all rounded-sm flex items-center justify-center gap-1">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                        <polyline points="14 2 14 8 20 8"></polyline>
                                        <line x1="12" y1="18" x2="12" y2="12"></line>
                                        <line x1="9" y1="15" x2="15" y2="15"></line>
                                    </svg>
                                    Upload CSV
                                </button>
                                <button @click="clearLoadSheet" :disabled="loadSheet.length === 0"
                                    class="py-2 text-[10px] uppercase tracking-widest bg-[#12100e] border border-border-med text-text-muted hover:text-white disabled:opacity-30 transition-all rounded-sm">
                                    Clear
                                </button>
                                <input type="file" id="loadSheetFile" accept=".csv" class="hidden"
                                    @change="handleLoadSheetUpload">
                            </div>

                            <div v-if="loadSheetStatus" class="text-[10px] font-mono"
                                :class="loadSheetStatus.startsWith('Error') ? 'text-red-500' : 'text-green-500'">
                                {{ loadSheetStatus }}
                            </div>

                            <button @click="showLoadSheetDialog = true"
                                class="w-full py-2 text-[10px] uppercase tracking-widest bg-[#1a1614] border border-border-med text-text-muted hover:text-white hover:border-sunset-glow transition-all rounded-sm flex items-center justify-center gap-2">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                                Manage Schedule
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Load Sheet Management Modal -->
        <div v-if="showLoadSheetDialog"
            class="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
            <div
                class="bg-[#0d0d0d] border border-border-low rounded-xl shadow-2xl w-full max-w-md overflow-hidden flex flex-col max-h-[90vh]">
                <div class="p-4 border-b border-border-low flex justify-between items-center bg-[#0a0a0a]">
                    <h2 class="text-xs text-text-muted uppercase tracking-widest font-bold">Duct Size Schedule</h2>
                    <button @click="showLoadSheetDialog = false"
                        class="text-text-muted hover:text-white transition-colors">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>

                <!-- Entry List -->
                <div class="flex-1 overflow-y-auto p-4 space-y-2 bg-[#090909]">
                    <div v-if="loadSheet.length === 0" class="text-center py-10 text-text-muted italic text-xs">
                        No entries in schedule.
                    </div>
                    <div v-for="(entry, idx) in loadSheet" :key="idx"
                        class="flex items-center justify-between p-3 bg-[#12100e] border border-border-med rounded-md group hover:border-sunset-glow/50 transition-all">
                        <div class="flex gap-4">
                            <div class="flex flex-col">
                                <span class="text-[9px] text-text-muted uppercase">CFM</span>
                                <span class="text-sm font-mono text-text-main">{{ entry.cfm.toLocaleString() }}</span>
                            </div>
                            <div class="flex flex-col">
                                <span class="text-[9px] text-text-muted uppercase">Size</span>
                                <span class="text-sm font-mono text-sunset-glow">{{ entry.ductSize }}</span>
                            </div>
                        </div>
                        <div class="flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button @click="openEditEntry(idx)"
                                class="p-1 text-text-muted hover:text-white transition-colors">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button @click="deleteEntry(idx)"
                                class="p-1 text-red-500/50 hover:text-red-500 transition-colors">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path
                                        d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                                    </path>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Add/Edit Form -->
                <div class="p-4 border-t border-border-low bg-[#0a0a0a] space-y-3">
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="text-[10px] text-text-muted uppercase block mb-1">CFM Value</label>
                            <input type="text" v-model="editCfm" placeholder="e.g. 1,000"
                                class="w-full bg-[#12100e] border border-border-med p-2 text-text-main outline-none font-mono text-sm focus:border-sunset-glow transition-all">
                        </div>
                        <div>
                            <label class="text-[10px] text-text-muted uppercase block mb-1">Duct Size</label>
                            <input type="text" v-model="editSize" placeholder="e.g. 12x8"
                                class="w-full bg-[#12100e] border border-border-med p-2 text-text-main outline-none font-mono text-sm focus:border-sunset-glow transition-all">
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="saveEntry"
                            class="flex-1 py-2 text-[10px] uppercase font-bold tracking-widest bg-sunset-glow text-bg hover:brightness-110 transition-all rounded-sm flex items-center justify-center gap-2">
                            {{ editingEntry === null ? 'Add Entry' : 'Update Entry' }}
                        </button>
                        <button v-if="editingEntry !== null" @click="editingEntry = null; editCfm = ''; editSize = ''"
                            class="px-4 py-2 text-[10px] uppercase tracking-widest border border-border-med text-text-muted hover:text-white transition-all rounded-sm">
                            Cancel Edit
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted, computed, nextTick } = Vue;

        createApp({
            setup() {
                const canvasRef = ref(null);
                const mode = ref("select"); // Default mode
                const defaultCfm = ref(500);
                const nodes = ref([]);
                const edges = ref([]);
                const history = ref([]);

                // Multi-selection State
                const selectedNodes = ref(new Set());
                const selectedEdges = ref(new Set());
                const dragStartPositions = ref(new Map());
                const dragStartMouse = ref({ x: 0, y: 0 });

                // Background Image State
                const backgroundImage = ref(null);
                // Structure: { src: base64, x: 0, y: 0, scale: 1, opacity: 0.5, width: 0, height: 0, aspectRatio: 1, element: HTMLImageElement }
                const isImageSelected = ref(false);
                const isDraggingImage = ref(false);

                // Computed helpers for property panel compatibility
                const singleSelectedNode = computed(() => {
                    if (selectedNodes.value.size === 1) {
                        return Array.from(selectedNodes.value)[0];
                    }
                    return null;
                });

                const singleSelectedEdge = computed(() => {
                    if (selectedEdges.value.size === 1) {
                        return Array.from(selectedEdges.value)[0];
                    }
                    return null;
                });

                // Check if selection contains only terminals (for bulk CFM edit)
                const allSelectedAreTerminals = computed(() => {
                    if (selectedNodes.value.size === 0 || selectedEdges.value.size > 0) return false;
                    for (const idx of selectedNodes.value) {
                        if (nodes.value[idx]?.type !== 'terminal') return false;
                    }
                    return true;
                });

                const bulkCfm = ref('');

                const applyBulkCfm = () => {
                    const cfmValue = parseFloat(bulkCfm.value);
                    if (isNaN(cfmValue) || cfmValue <= 0) {
                        alert('Please enter a valid CFM value');
                        return;
                    }
                    saveHistory();
                    selectedNodes.value.forEach(idx => {
                        if (nodes.value[idx]?.type === 'terminal') {
                            nodes.value[idx].cfm = cfmValue;
                        }
                    });
                    bulkCfm.value = '';
                    recalcAndRender();
                };

                const selectionBox = ref({ startX: 0, startY: 0, endX: 0, endY: 0, active: false });
                const isDraggingSelection = ref(false);

                const selectedNode = ref(null); // DEPRECATED: Kept briefly to minimize diff noise during transition, but will be removed.
                const selectedEdge = ref(null); // DEPRECATED

                const hoveredEdge = ref(null);
                const mousePos = ref({ x: 0, y: 0 }); // Screen coordinates
                const mouseWorld = ref({ x: 0, y: 0 }); // World coordinates

                // Interaction State
                const transform = ref({ scale: 1, offsetX: 0, offsetY: 0 });
                const snapToGrid = ref(true);
                const isPanning = ref(false);
                const draggingNode = ref(null); // Index of node being dragged
                const lastMouse = ref({ x: 0, y: 0 });

                const canvasWidth = ref(1200);
                const canvasHeight = ref(800);

                // Load Sheet State
                const loadSheet = ref([]); // Array of { cfm: number, ductSize: string }, sorted by cfm
                const loadSheetColumns = ref({ cfmCol: 'CFM', sizeCol: 'Size' });
                const loadSheetStatus = ref(''); // Status message for UI
                const isScheduleExpanded = ref(false); // Collapsible state

                const tools = [
                    { id: "select", label: "Select / Edit" },
                    { id: "move", label: "Move Node" }, // New Tool
                    { id: "terminal", label: "Add Terminal" },
                    { id: "branch", label: "Add Junction" },
                    { id: "duct", label: "Draw Duct" },
                    { id: "flip", label: "Flip Flow" },
                    { id: "image", label: "Image Mode" },
                ];

                const setTool = (id) => {
                    mode.value = id;
                    // If switching to tools that require no selection, maybe clear?
                    // keeping selection allows contextual actions though.
                    if (id !== "select") {
                        // selectedNode.value = null;
                    }
                };

                const deleteSelected = () => {
                    if (selectedNodes.value.size === 0 && selectedEdges.value.size === 0) return;

                    saveHistory();

                    // Convert sets to arrays for processing
                    const nodesToDelete = Array.from(selectedNodes.value).sort((a, b) => b - a);

                    // Remove edges connected to deleted nodes first
                    const newEdges = [];
                    edges.value.forEach((e, idx) => {
                        const explicitDelete = selectedEdges.value.has(idx);
                        const nodeDelete = nodesToDelete.includes(e.from) || nodesToDelete.includes(e.to);

                        if (!explicitDelete && !nodeDelete) {
                            newEdges.push(e);
                        }
                    });

                    edges.value = newEdges;

                    // Remove nodes
                    // We must remove from highest index to lowest to avoid shifting issues
                    nodesToDelete.forEach(idx => {
                        nodes.value.splice(idx, 1);
                        // Adjust edge indices for remaining edges
                        edges.value.forEach(e => {
                            if (e.from > idx) e.from--;
                            if (e.to > idx) e.to--;
                        });
                    });

                    // Clear Selection
                    selectedNodes.value.clear();
                    selectedEdges.value.clear();
                    recalcAndRender();
                };

                const handleKeydown = (e) => {
                    if (e.key === "Escape") {
                        if (draggingNode.value !== null) {
                            draggingNode.value = null;
                        }
                        selectedNodes.value.clear();
                        selectedEdges.value.clear();
                        render();
                    }
                    if (e.key === "Delete") {
                        deleteSelected();
                    }
                };

                // --- PERSISTENCE ---
                const saveToLocalStorage = () => {
                    const data = {
                        nodes: nodes.value,
                        edges: edges.value,
                        version: 1,
                        backgroundImage: backgroundImage.value ? { ...backgroundImage.value, element: undefined } : null
                    };
                    localStorage.setItem("ariflow_data", JSON.stringify(data));
                };

                const loadFromLocalStorage = () => {
                    const raw = localStorage.getItem("ariflow_data");
                    if (raw) {
                        try {
                            const data = JSON.parse(raw);
                            if (data.nodes && data.edges) {
                                nodes.value = data.nodes;
                                edges.value = data.edges;

                                if (data.backgroundImage) {
                                    backgroundImage.value = data.backgroundImage;
                                    const img = new Image();
                                    img.onload = () => { if (backgroundImage.value) backgroundImage.value.element = img; recalcAndRender(); };
                                    img.src = data.backgroundImage.src;
                                }
                            }
                        } catch (e) {
                            console.error("Failed to load local data", e);
                        }
                    }
                };

                const exportJSON = () => {
                    const data = {
                        nodes: nodes.value,
                        edges: edges.value,
                        loadSheet: loadSheet.value,
                        loadSheetColumns: loadSheetColumns.value,
                        version: 1,
                        timestamp: new Date().toISOString(),
                        backgroundImage: backgroundImage.value ? { ...backgroundImage.value, element: undefined } : null
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `airflow-design-${new Date().toISOString().slice(0, 10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                };

                const importJSON = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (data.nodes && data.edges) {
                                saveHistory(); // Save current before overwriting
                                nodes.value = data.nodes;
                                edges.value = data.edges;

                                if (data.loadSheet) {
                                    loadSheet.value = data.loadSheet;
                                    if (data.loadSheetColumns) {
                                        loadSheetColumns.value = data.loadSheetColumns;
                                    }
                                    loadSheetStatus.value = `${loadSheet.value.length} sizes loaded`;
                                    loadSheetStatus.value = `${loadSheet.value.length} sizes loaded`;
                                    saveLoadSheetToStorage();
                                }

                                if (data.backgroundImage) {
                                    backgroundImage.value = data.backgroundImage;
                                    const img = new Image();
                                    img.onload = () => { if (backgroundImage.value) backgroundImage.value.element = img; recalcAndRender(); };
                                    img.src = data.backgroundImage.src;
                                }

                                selectedNodes.value.clear();
                                selectedEdges.value.clear();
                                recalcAndRender();
                            } else {
                                alert("Invalid JSON file format");
                            }
                        } catch (err) {
                            console.error(err);
                            alert("Error parsing JSON file");
                        }
                        // Reset input
                        event.target.value = "";
                    };
                    reader.readAsText(file);
                };

                const triggerImport = () => {
                    document.getElementById('importFile').click();
                };

                // --- LOAD SHEET FUNCTIONS ---
                const parseLoadSheetCSV = (csvText) => {
                    const lines = csvText.trim().split(/\r?\n/);
                    if (lines.length < 2) {
                        loadSheetStatus.value = 'Error: CSV has no data rows';
                        return;
                    }

                    // Parse header
                    const headers = lines[0].split(',').map(h => h.trim());
                    const cfmIdx = headers.findIndex(h => h.toLowerCase() === loadSheetColumns.value.cfmCol.toLowerCase());
                    const sizeIdx = headers.findIndex(h => h.toLowerCase() === loadSheetColumns.value.sizeCol.toLowerCase());

                    if (cfmIdx === -1 || sizeIdx === -1) {
                        loadSheetStatus.value = `Error: Columns "${loadSheetColumns.value.cfmCol}" or "${loadSheetColumns.value.sizeCol}" not found`;
                        return;
                    }

                    // Parse data rows with proper CSV handling (respects quoted fields)
                    const parseCSVLine = (line) => {
                        const result = [];
                        let current = '';
                        let inQuotes = false;
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        result.push(current.trim());
                        return result;
                    };

                    const entries = [];
                    for (let i = 1; i < lines.length; i++) {
                        const cols = parseCSVLine(lines[i]);
                        // Strip commas from CFM value (handles "1,000" format)
                        const cfmRaw = (cols[cfmIdx] || '').replace(/,/g, '');
                        const cfmVal = parseFloat(cfmRaw);
                        let sizeVal = cols[sizeIdx];
                        if (!isNaN(cfmVal) && sizeVal) {
                            // Strip inch symbols and normalize
                            sizeVal = sizeVal.replace(/["']/g, '').trim();
                            // Normalize x separator to lowercase x
                            sizeVal = sizeVal.replace(/\s*[xX]\s*/g, 'x');
                            entries.push({ cfm: cfmVal, ductSize: sizeVal });
                        }
                    }

                    // Sort by CFM ascending
                    entries.sort((a, b) => a.cfm - b.cfm);
                    loadSheet.value = entries;
                    loadSheetStatus.value = `${entries.length} sizes loaded`;
                    saveLoadSheetToStorage();

                    // Apply to existing ducts
                    applyDuctSizes();
                    recalcAndRender();
                };

                const handleLoadSheetUpload = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        parseLoadSheetCSV(e.target.result);
                        event.target.value = "";
                    };
                    reader.readAsText(file);
                };

                const triggerLoadSheetUpload = () => {
                    document.getElementById('loadSheetFile').click();
                };

                // Load Sheet Persistence
                const saveLoadSheetToStorage = () => {
                    localStorage.setItem("ariflow_loadsheet", JSON.stringify(loadSheet.value));
                };

                const loadLoadSheetFromStorage = () => {
                    const raw = localStorage.getItem("ariflow_loadsheet");
                    if (raw) {
                        try {
                            loadSheet.value = JSON.parse(raw);
                            if (loadSheet.value.length > 0) {
                                loadSheetStatus.value = `${loadSheet.value.length} sizes loaded`;
                            }
                        } catch (e) {
                            console.error("Failed to load load sheet", e);
                        }
                    }
                };

                // Edit Dialog State
                const showLoadSheetDialog = ref(false);
                const editingEntry = ref(null); // null = adding new, otherwise index
                const editCfm = ref('');
                const editSize = ref('');

                const openAddEntry = () => {
                    editingEntry.value = null;
                    editCfm.value = '';
                    editSize.value = '';
                    showLoadSheetDialog.value = true;
                };

                const openEditEntry = (idx) => {
                    editingEntry.value = idx;
                    editCfm.value = loadSheet.value[idx].cfm.toString();
                    editSize.value = loadSheet.value[idx].ductSize;
                    showLoadSheetDialog.value = true;
                };

                const saveEntry = () => {
                    const cfmVal = parseFloat(editCfm.value.replace(/,/g, ''));
                    const sizeVal = editSize.value.trim().replace(/["']/g, '').replace(/\s*[xX]\s*/g, 'x');

                    if (isNaN(cfmVal) || !sizeVal) {
                        alert("Please enter valid CFM and Size values");
                        return;
                    }

                    if (editingEntry.value === null) {
                        // Add new
                        loadSheet.value.push({ cfm: cfmVal, ductSize: sizeVal });
                    } else {
                        // Update existing
                        loadSheet.value[editingEntry.value] = { cfm: cfmVal, ductSize: sizeVal };
                    }

                    // Re-sort by CFM
                    loadSheet.value.sort((a, b) => a.cfm - b.cfm);
                    loadSheetStatus.value = `${loadSheet.value.length} sizes loaded`;
                    saveLoadSheetToStorage();
                    showLoadSheetDialog.value = false;
                    recalcAndRender();
                };

                const deleteEntry = (idx) => {
                    loadSheet.value.splice(idx, 1);
                    loadSheetStatus.value = loadSheet.value.length > 0 ? `${loadSheet.value.length} sizes loaded` : '';
                    saveLoadSheetToStorage();
                    recalcAndRender();
                };

                const clearLoadSheet = () => {
                    loadSheet.value = [];
                    loadSheetStatus.value = '';
                    localStorage.removeItem("ariflow_loadsheet");
                    // Clear duct sizes from edges
                    edges.value.forEach(e => {
                        delete e.ductSize;
                    });
                    recalcAndRender();
                };

                // --- BACKGROUND IMAGE ---
                const handleImageUpload = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            // Initialize background image centered? or at 0,0
                            // Let's put it at 0,0 world coords
                            backgroundImage.value = {
                                src: e.target.result,
                                x: 0,
                                y: 0,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                scale: 1,
                                opacity: 0.5,
                                element: img
                            };
                            isImageSelected.value = true;
                            recalcAndRender();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                    event.target.value = "";
                };

                const triggerImageUpload = () => {
                    document.getElementById('bgImageInput').click();
                };

                const deleteImage = () => {
                    backgroundImage.value = null;
                    isImageSelected.value = false;
                    isDraggingImage.value = false;
                    recalcAndRender();
                };

                // --- DUCT SIZING SUGGESTION ---
                const targetHeadLoss = ref(0.08);

                const calculateDuctDimension = (edgeIdx, solveFor) => {
                    const edge = edges.value[edgeIdx];
                    if (!edge) return;

                    const cfm = edge.flow;
                    const hl = targetHeadLoss.value;
                    if (!cfm || !hl) return;

                    // 1. Calculate Equivalent Diameter (De)
                    const De = Math.pow(
                        (0.109136 * Math.pow(cfm, 1.9)) / hl,
                        1 / 5.02
                    );

                    let knownDim = 0;
                    if (solveFor === 'height') {
                        knownDim = parseFloat(edge.customWidth);
                    } else {
                        knownDim = parseFloat(edge.customHeight);
                    }

                    if (!knownDim || isNaN(knownDim)) return;

                    // 2. Solve for unknown dimension
                    let h = 1;
                    const w = knownDim; // Treat known as width in formula, solve for height 'h'

                    // Iterative solve
                    while (
                        1.3 *
                        Math.pow(Math.pow(w * h, 0.625) / Math.pow(w + h, 0.25), 1) <
                        De
                    ) {
                        h += 0.5;
                        if (h > 500) break;
                    }
                    // Refine
                    while (
                        1.3 *
                        Math.pow(Math.pow(w * h, 0.625) / Math.pow(w + h, 0.25), 1) >
                        De
                    ) {
                        h -= 0.01;
                    }

                    const result = Math.round(h);

                    if (solveFor === 'height') {
                        edge.customHeight = result;
                    } else {
                        edge.customWidth = result;
                    }

                    edge.customSize = `${edge.customWidth}x${edge.customHeight}`;
                    recalcAndRender();
                };

                const getDuctSizeForCFM = (cfmValue) => {
                    if (loadSheet.value.length === 0) return null;

                    // Floor lookup: find largest entry where entry.cfm <= cfmValue
                    let result = null;
                    for (const entry of loadSheet.value) {
                        if (entry.cfm <= cfmValue) {
                            result = entry.ductSize;
                        } else {
                            break; // Since sorted, no need to continue
                        }
                    }
                    return result;
                };

                const applyDuctSizes = () => {
                    // Apply duct sizes to edges based on their flow CFM
                    edges.value.forEach(e => {
                        if (e.isCustom && e.customSize) {
                            e.ductSize = e.customSize; // Use manual override
                        } else {
                            e.ductSize = getDuctSizeForCFM(e.flow) || null;
                        }
                    });
                };

                // --- COORDINATE SYSTEMS ---
                const screenToWorld = (sx, sy) => {
                    return {
                        x: (sx - transform.value.offsetX) / transform.value.scale,
                        y: (sy - transform.value.offsetY) / transform.value.scale
                    };
                };

                const getDistToEdge = (px, py, x1, y1, x2, y2) => {
                    const l2 = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
                    if (l2 === 0) return Math.hypot(px - x1, py - y1);
                    let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    return Math.hypot(
                        px - (x1 + t * (x2 - x1)),
                        py - (y1 + t * (y2 - y1))
                    );
                };

                const saveHistory = () => {
                    history.value.push(
                        JSON.stringify({
                            nodes: nodes.value,
                            edges: edges.value,
                        })
                    );
                    if (history.value.length > 20) history.value.shift();
                };

                const undo = () => {
                    if (history.value.length === 0) return;
                    const state = JSON.parse(history.value.pop());
                    nodes.value = state.nodes;
                    edges.value = state.edges;
                    selectedNodes.value.clear();
                    selectedEdges.value.clear();
                    recalcAndRender();
                };

                const recalcAndRender = () => {
                    calculateFlows();
                    applyDuctSizes();
                    saveToLocalStorage();
                    render();
                };

                const calculateFlows = () => {
                    edges.value.forEach((e) => (e.flow = 0));

                    const getReachableCFM = (startNode, visited = new Set()) => {
                        if (visited.has(startNode)) return 0;
                        visited.add(startNode);

                        let total =
                            nodes.value[startNode].type === "terminal"
                                ? nodes.value[startNode].cfm
                                : 0;

                        edges.value
                            .filter((e) => e.from === startNode)
                            .forEach((e) => {
                                const down = getReachableCFM(e.to, visited);
                                e.flow = down;
                            });

                        const outgoing = edges.value
                            .filter((e) => e.from === startNode)
                            .reduce((acc, e) => acc + e.flow, 0);

                        const totalFlow = total + outgoing;
                        nodes.value[startNode].flow = totalFlow;
                        return totalFlow;
                    };

                    const roots = nodes.value
                        .map((_, i) => i)
                        .filter((i) => !edges.value.some((e) => e.to === i));
                    roots.forEach((r) => getReachableCFM(r));
                };

                // --- INTERACTION HANDLERS ---

                const resetView = () => {
                    transform.value = { scale: 1, offsetX: 0, offsetY: 0 };
                    render();
                };

                const handleWheel = (e) => {
                    const zoomIntensity = 0.1;
                    const direction = e.deltaY > 0 ? -1 : 1;
                    const factor = 1 + (direction * zoomIntensity);

                    // Zoom point (mouse pos)
                    const rect = canvasRef.value.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // World before zoom
                    const wx = (mouseX - transform.value.offsetX) / transform.value.scale;
                    const wy = (mouseY - transform.value.offsetY) / transform.value.scale;

                    // Apply zoom
                    let newScale = transform.value.scale * factor;
                    newScale = Math.max(0.1, Math.min(newScale, 5)); // Limits

                    transform.value.scale = newScale;

                    // Adjust offset to keep mouse world point stable
                    transform.value.offsetX = mouseX - wx * newScale;
                    transform.value.offsetY = mouseY - wy * newScale;

                    render();
                };

                const updateMouse = (e) => {
                    const rect = canvasRef.value.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    mousePos.value = { x: mx, y: my };

                    // Current World Coord (for drawing preview etc)
                    const w = screenToWorld(mx, my);
                    mouseWorld.value = w;

                    // PANNING
                    if (isPanning.value) {
                        const dx = mx - lastMouse.value.x;
                        const dy = my - lastMouse.value.y;
                        transform.value.offsetX += dx;
                        transform.value.offsetY += dy;
                        lastMouse.value = { x: mx, y: my };
                        render();
                        return;
                    }

                    // DRAGGING IMAGE
                    if (isDraggingImage.value && backgroundImage.value) {
                        const dx = (mx - dragStartMouse.value.x) / transform.value.scale;
                        const dy = (my - dragStartMouse.value.y) / transform.value.scale;

                        const startPos = dragStartPositions.value.get('image');
                        if (startPos) {
                            backgroundImage.value.x = startPos.x + dx;
                            backgroundImage.value.y = startPos.y + dy;
                        }
                        render();
                        return;
                    }

                    // DRAGGING SELECTION
                    if (isDraggingSelection.value && dragStartPositions.value.size > 0) {
                        // Calculate total delta from start (Screen -> World)
                        const dx = (mx - dragStartMouse.value.x) / transform.value.scale;
                        const dy = (my - dragStartMouse.value.y) / transform.value.scale;

                        // Get leader node (primary selection) for snapping reference
                        let leaderId = draggingNode.value;
                        if (leaderId === null || !selectedNodes.value.has(leaderId)) {
                            if (selectedNodes.value.size > 0) {
                                leaderId = Array.from(selectedNodes.value)[0];
                            } else {
                                return;
                            }
                        }

                        const leaderStart = dragStartPositions.value.get(leaderId);
                        if (!leaderStart) return;

                        // Calculate Target Leader Position
                        let tx = leaderStart.x + dx;
                        let ty = leaderStart.y + dy;

                        if (snapToGrid.value) {
                            tx = Math.round(tx / 20) * 20;
                            ty = Math.round(ty / 20) * 20;
                        }

                        // Calculate Effective Delta (Snapped)
                        const effectiveDx = tx - leaderStart.x;
                        const effectiveDy = ty - leaderStart.y;

                        // Apply to all
                        selectedNodes.value.forEach(idx => {
                            const startPos = dragStartPositions.value.get(idx);
                            if (startPos) {
                                nodes.value[idx].x = startPos.x + effectiveDx;
                                nodes.value[idx].y = startPos.y + effectiveDy;
                            }
                        });

                        lastMouse.value = { x: mx, y: my };
                        recalcAndRender();
                        return;
                    }

                    // BOX SELECTION
                    if (selectionBox.value.active) {
                        selectionBox.value.endX = w.x;
                        selectionBox.value.endY = w.y;

                        const bx = Math.min(selectionBox.value.startX, selectionBox.value.endX);
                        const by = Math.min(selectionBox.value.startY, selectionBox.value.endY);
                        const bw = Math.abs(selectionBox.value.endX - selectionBox.value.startX);
                        const bh = Math.abs(selectionBox.value.endY - selectionBox.value.startY);

                        selectedNodes.value.clear();
                        selectedEdges.value.clear();

                        nodes.value.forEach((n, i) => {
                            if (n.x >= bx && n.x <= bx + bw && n.y >= by && n.y <= by + bh) {
                                selectedNodes.value.add(i);
                            }
                        });

                        edges.value.forEach((e, i) => {
                            const n1 = nodes.value[e.from];
                            const n2 = nodes.value[e.to];
                            const midX = (n1.x + n2.x) / 2;
                            const midY = (n1.y + n2.y) / 2;
                            if (midX >= bx && midX <= bx + bw && midY >= by && midY <= by + bh) {
                                selectedEdges.value.add(i);
                            }
                        });

                        render();
                        return;
                    }

                    // HOVER CHECKS
                    let minDist = 20 / transform.value.scale;
                    let foundIdx = null;
                    edges.value.forEach((edge, idx) => {
                        const n1 = nodes.value[edge.from];
                        const n2 = nodes.value[edge.to];
                        const d = getDistToEdge(w.x, w.y, n1.x, n1.y, n2.x, n2.y);
                        if (d < minDist) {
                            minDist = d;
                            foundIdx = idx;
                        }
                    });
                    hoveredEdge.value = foundIdx;
                    render();
                };

                const handleCanvasClick = (e) => { // Actual mousedown
                    const rect = canvasRef.value.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    lastMouse.value = { x: mx, y: my };

                    // Pan Check (Middle Click or Alt)
                    if (e.button === 1 || e.altKey) {
                        isPanning.value = true;
                        return;
                    }

                    saveHistory();
                    const w = screenToWorld(mx, my);
                    let finalX = w.x;
                    let finalY = w.y;

                    // Apply Snap on Click (for new Nodes)
                    if (snapToGrid.value && (mode.value === 'terminal' || mode.value === 'branch')) {
                        finalX = Math.round(finalX / 20) * 20;
                        finalY = Math.round(finalY / 20) * 20;
                    }

                    // Hit test nodes (radius constant 25 for easier selection)
                    const clickedNodeIdx = nodes.value.findIndex(
                        (n) => Math.hypot(n.x - w.x, n.y - w.y) < 25
                    );

                    // MOVE / SELECT TOOL
                    if (mode.value === "move" || mode.value === "select") {
                        if (clickedNodeIdx !== -1) {
                            // Node Clicked
                            if (e.shiftKey) {
                                // Toggle Selection
                                if (selectedNodes.value.has(clickedNodeIdx)) {
                                    selectedNodes.value.delete(clickedNodeIdx);
                                } else {
                                    selectedNodes.value.add(clickedNodeIdx);
                                }
                            } else {
                                // Single Select (unless already selected, then maybe start drag)
                                // If we click a node that is part of the selection, we DON'T clear, 
                                // because we might be about to drag the whole group.
                                if (!selectedNodes.value.has(clickedNodeIdx)) {
                                    selectedNodes.value.clear();
                                    selectedEdges.value.clear();
                                    selectedNodes.value.add(clickedNodeIdx);
                                }
                            }

                            // Drag Initialization (Only in Move Mode)
                            if (mode.value === 'move') {
                                isDraggingSelection.value = true;
                                draggingNode.value = clickedNodeIdx; // Leader node for snapping

                                // Capture initial state
                                dragStartMouse.value = { x: mx, y: my };
                                dragStartPositions.value.clear();
                                selectedNodes.value.forEach(id => {
                                    if (nodes.value[id]) {
                                        dragStartPositions.value.set(id, { x: nodes.value[id].x, y: nodes.value[id].y });
                                    }
                                });
                            } else {
                                isDraggingSelection.value = false;
                                draggingNode.value = null;
                            }
                        } else {
                            // Empty Space or Edge

                            // Check Edge Click
                            let minDist = 10 / transform.value.scale;
                            let foundEdgeIdx = -1;

                            edges.value.forEach((edge, idx) => {
                                const n1 = nodes.value[edge.from];
                                const n2 = nodes.value[edge.to];
                                const d = getDistToEdge(w.x, w.y, n1.x, n1.y, n2.x, n2.y);
                                if (d < minDist) {
                                    minDist = d;
                                    foundEdgeIdx = idx;
                                }
                            });

                            if (foundEdgeIdx !== -1) {
                                if (e.shiftKey) {
                                    if (selectedEdges.value.has(foundEdgeIdx)) {
                                        selectedEdges.value.delete(foundEdgeIdx);
                                    } else {
                                        selectedEdges.value.add(foundEdgeIdx);
                                    }
                                } else {
                                    selectedNodes.value.clear();
                                    selectedEdges.value.clear();
                                    selectedEdges.value.add(foundEdgeIdx);
                                }
                            } else {
                                // Empty space -> Box Select
                                if (!e.shiftKey) {
                                    selectedNodes.value.clear();
                                    selectedEdges.value.clear();
                                }
                                if (mode.value === "select") {
                                    selectionBox.value = { startX: w.x, startY: w.y, endX: w.x, endY: w.y, active: true };
                                }
                            }
                        }
                    }

                    // ADD TERMINAL
                    else if (mode.value === "terminal") {
                        if (clickedNodeIdx === -1) {
                            nodes.value.push({
                                x: finalX,
                                y: finalY,
                                cfm: defaultCfm.value,
                                type: "terminal",
                            });
                            selectedNodes.value.clear();
                            selectedEdges.value.clear();
                            selectedNodes.value.add(nodes.value.length - 1);
                        }
                    }

                    // ADD JUNCTION
                    else if (mode.value === "branch") {
                        if (clickedNodeIdx === -1) {
                            nodes.value.push({ x: finalX, y: finalY, cfm: 0, type: "branch" });
                            selectedNodes.value.clear();
                            selectedEdges.value.clear();
                            selectedNodes.value.add(nodes.value.length - 1);
                        }
                    }

                    // DRAW DUCT
                    else if (mode.value === "duct") {
                        if (clickedNodeIdx !== -1) {
                            // Use the last selected node as source if available
                            let fromNode = null;
                            if (selectedNodes.value.size === 1) {
                                fromNode = Array.from(selectedNodes.value)[0];
                            }

                            if (fromNode !== null && nodes.value[fromNode]) {
                                if (fromNode !== clickedNodeIdx) {
                                    const exists = edges.value.some(
                                        (e) =>
                                            (e.from === fromNode && e.to === clickedNodeIdx) ||
                                            (e.to === fromNode && e.from === clickedNodeIdx)
                                    );
                                    if (!exists) {
                                        edges.value.push({
                                            from: fromNode,
                                            to: clickedNodeIdx,
                                            flow: 0,
                                        });
                                        // Select new target for chain creation
                                        selectedNodes.value.clear();
                                        selectedNodes.value.add(clickedNodeIdx);
                                    }
                                }
                            } else {
                                selectedNodes.value.clear();
                                selectedNodes.value.add(clickedNodeIdx);
                                selectedEdges.value.clear();
                            }
                        }
                    }

                    // IMAGE MODE
                    else if (mode.value === "image") {
                        if (backgroundImage.value) {
                            const bx = backgroundImage.value.x;
                            const by = backgroundImage.value.y;
                            const bw = backgroundImage.value.width * backgroundImage.value.scale;
                            const bh = backgroundImage.value.height * backgroundImage.value.scale;

                            // Hit test
                            if (w.x >= bx && w.x <= bx + bw && w.y >= by && w.y <= by + bh) {
                                isImageSelected.value = true;
                                isDraggingImage.value = true;
                                // Use dragStartMouse from multi-select logic or create new?
                                // Reuse dragStartMouse is fine.
                                dragStartMouse.value = { x: mx, y: my };
                                dragStartPositions.value.clear(); // not used for image but good to clear
                                // Store initial image pos in dragStartPositions with key 'image'?
                                // No, just use refs or a temp logic.
                                // Start Pos
                                dragStartPositions.value.set('image', { x: bx, y: by });
                            } else {
                                isImageSelected.value = false;
                            }
                        }
                    } else {
                        // If switching modes, deselect image?
                        isImageSelected.value = false;
                    }

                    // FLIP
                    if (mode.value === "flip" && hoveredEdge.value !== null) {
                        const e = edges.value[hoveredEdge.value];
                        [e.from, e.to] = [e.to, e.from];
                    }

                    recalcAndRender();
                };

                const handleMouseUp = () => {
                    isPanning.value = false;
                    draggingNode.value = null;
                    isDraggingSelection.value = false;
                    isDraggingImage.value = false;
                    selectionBox.value.active = false;
                };

                const render = () => {
                    if (!canvasRef.value) return;
                    const ctx = canvasRef.value.getContext("2d");
                    ctx.clearRect(0, 0, canvasWidth.value, canvasHeight.value);

                    ctx.save();

                    // Scale for device pixel ratio (retina displays, zoom)
                    const dpr = window.devicePixelRatio || 1;
                    ctx.scale(dpr, dpr);

                    // Apply Transformations
                    ctx.translate(transform.value.offsetX, transform.value.offsetY);
                    ctx.scale(transform.value.scale, transform.value.scale);

                    // Background Image
                    if (backgroundImage.value && backgroundImage.value.src) {
                        if (!backgroundImage.value.element) {
                            const img = new Image();
                            img.src = backgroundImage.value.src;
                            backgroundImage.value.element = img;
                        }

                        if (backgroundImage.value.element.complete && backgroundImage.value.element.naturalWidth !== 0) {
                            ctx.save();
                            ctx.globalAlpha = backgroundImage.value.opacity;
                            const w = backgroundImage.value.width * backgroundImage.value.scale;
                            const h = backgroundImage.value.height * backgroundImage.value.scale;
                            ctx.drawImage(backgroundImage.value.element, backgroundImage.value.x, backgroundImage.value.y, w, h);
                            ctx.restore();

                            // Selection Border
                            if (isImageSelected.value && mode.value === 'image') {
                                ctx.save();
                                ctx.strokeStyle = "#ff8c42";
                                ctx.lineWidth = 2 / transform.value.scale;
                                ctx.strokeRect(backgroundImage.value.x, backgroundImage.value.y, w, h);
                                ctx.restore();
                            }
                        }
                    }

                    // Grid Drawing (Infinite-ish)
                    // We need to calculate visible world bounds
                    const tl = screenToWorld(0, 0);
                    const br = screenToWorld(canvasWidth.value, canvasHeight.value);

                    ctx.strokeStyle = "#1a1614";
                    ctx.lineWidth = 1 / transform.value.scale; // Keep line width constant on screen

                    const gridSize = 40;
                    const startX = Math.floor(tl.x / gridSize) * gridSize;
                    const endX = Math.ceil(br.x / gridSize) * gridSize;
                    const startY = Math.floor(tl.y / gridSize) * gridSize;
                    const endY = Math.ceil(br.y / gridSize) * gridSize;

                    for (let i = startX; i <= endX; i += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(i, startY);
                        ctx.lineTo(i, endY);
                        ctx.stroke();
                    }
                    for (let i = startY; i <= endY; i += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(startX, i);
                        ctx.lineTo(endX, i);
                        ctx.stroke();
                    }

                    // Draw Arrow Helper
                    const drawArrow = (ctx, x1, y1, x2, y2) => {
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const mx = (x1 + x2) / 2;
                        const my = (y1 + y2) / 2;

                        ctx.save();
                        ctx.translate(mx, my);
                        ctx.rotate(angle);

                        const headLen = 6 / transform.value.scale; // Scale arrow head? No, usually icons scale with zoom or stay fixed? 
                        // Previous code used constant 6. If we zoom in, it gets bigger. Which is standard canvas behavior.
                        // Let's keep it standard.

                        ctx.beginPath();
                        ctx.moveTo(-6, -3);
                        ctx.lineTo(6, 0);
                        ctx.lineTo(-6, 3);
                        ctx.fillStyle = "#ff8c42";
                        ctx.fill();

                        ctx.restore();
                    };

                    // Edges (Ducts)
                    edges.value.forEach((e, idx) => {
                        const n1 = nodes.value[e.from];
                        const n2 = nodes.value[e.to];
                        const isHovered = (hoveredEdge.value === idx && mode.value === "flip");

                        ctx.beginPath();
                        ctx.moveTo(n1.x, n1.y);
                        ctx.lineTo(n2.x, n2.y);

                        const isSelected = selectedEdges.value.has(idx);
                        ctx.strokeStyle = (isHovered || isSelected) ? (isSelected ? "#sunset-glow" : "#ffffff") : "#2d2621";
                        if (isSelected) {
                            ctx.strokeStyle = "#ff8c42"; // Selected Color
                            ctx.shadowColor = "#ff8c42";
                            ctx.shadowBlur = 10;
                        } else {
                            ctx.shadowBlur = 0;
                        }

                        ctx.lineWidth = Math.max(6, Math.min(20, 6 + e.flow / 200));
                        ctx.lineCap = "round";
                        ctx.stroke();

                        drawArrow(ctx, n1.x, n1.y, n2.x, n2.y);

                        if (e.flow > 0) {
                            const mx = (n1.x + n2.x) / 2;
                            const my = (n1.y + n2.y) / 2;
                            ctx.fillStyle = "#ff8c42";
                            ctx.font = `bold 10px "Roboto Mono"`;
                            ctx.textAlign = "center";
                            ctx.fillText(`${e.flow} CFM`, mx, my - 12);

                            // Show duct size if available (below arrow)
                            if (e.ductSize) {
                                ctx.fillStyle = "#fff";
                                ctx.font = `bold 11px "Roboto Mono"`;
                                ctx.fillText(e.ductSize, mx, my + 16);
                            }
                        }
                    });

                    // Preview Line (Duct Draw)
                    if (mode.value === "duct" && selectedNodes.value.size === 1) {
                        const idx = Array.from(selectedNodes.value)[0];
                        const sn = nodes.value[idx];

                        // MouseWorld is updated in updateMouse
                        let tx = mouseWorld.value.x;
                        let ty = mouseWorld.value.y;

                        if (snapToGrid.value) {
                            tx = Math.round(tx / 20) * 20;
                            ty = Math.round(ty / 20) * 20;
                        }

                        ctx.beginPath();
                        ctx.moveTo(sn.x, sn.y);
                        ctx.lineTo(tx, ty);
                        ctx.strokeStyle = "#ff8c42";
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Nodes
                    nodes.value.forEach((n, i) => {
                        const isSelected = selectedNodes.value.has(i);

                        if (n.type === "terminal") {
                            // Symbol: Box with X
                            const size = 12;
                            ctx.save();
                            ctx.translate(n.x, n.y);

                            // Fill background
                            ctx.fillStyle = "#0d0d0d";
                            ctx.fillRect(-size, -size, size * 2, size * 2);

                            // Stroke
                            ctx.strokeStyle = isSelected ? "#fff" : "#ff8c42";
                            ctx.lineWidth = 2;
                            ctx.strokeRect(-size, -size, size * 2, size * 2);

                            // X
                            ctx.beginPath();
                            ctx.moveTo(-size, -size);
                            ctx.lineTo(size, size);
                            ctx.moveTo(size, -size);
                            ctx.lineTo(-size, size);
                            ctx.stroke();

                            ctx.restore();

                            // Labels
                            ctx.textAlign = "center";
                            if (n.cfm) {
                                ctx.fillStyle = isSelected ? "#fff" : "#6b5c54";
                                ctx.font = '9px "Inter"';
                                ctx.fillText(`${n.cfm} CFM`, n.x, n.y + size + 12);
                            }
                        } else {

                            ctx.beginPath();
                            ctx.arc(n.x, n.y, 4, 0, Math.PI * 2);
                            ctx.fillStyle = isSelected ? "#fff" : "#4a3728";
                            ctx.fill();
                            ctx.strokeStyle = isSelected ? "#fff" : "#4a3728";
                            ctx.stroke();
                        }
                    });

                    // Selection Box
                    if (selectionBox.value.active) {
                        const bx = Math.min(selectionBox.value.startX, selectionBox.value.endX);
                        const by = Math.min(selectionBox.value.startY, selectionBox.value.endY);
                        const bw = Math.abs(selectionBox.value.endX - selectionBox.value.startX);
                        const bh = Math.abs(selectionBox.value.endY - selectionBox.value.startY);

                        ctx.save();
                        ctx.strokeStyle = "#ff8c42";
                        ctx.lineWidth = 1 / transform.value.scale;
                        ctx.setLineDash([5 / transform.value.scale, 5 / transform.value.scale]);
                        ctx.strokeRect(bx, by, bw, bh);
                        ctx.fillStyle = "rgba(255, 140, 66, 0.1)";
                        ctx.fillRect(bx, by, bw, bh);
                        ctx.restore();
                    }

                    ctx.restore(); // Restore Identity for any UI overlays? 
                    // Currently no screen-space UI overlays in canvas path.
                };

                const clearAll = () => {
                    nodes.value = [];
                    edges.value = [];
                    selectedNodes.value.clear();
                    selectedEdges.value.clear();
                    backgroundImage.value = null;
                    isImageSelected.value = false;
                    render();
                };

                onMounted(() => {
                    // Initial canvas sizing with DPI scaling
                    const container = canvasRef.value.parentElement;
                    const updateCanvasSize = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const displayWidth = container.clientWidth;
                        const displayHeight = container.clientHeight;

                        // Set canvas internal resolution (scaled by DPR)
                        canvasWidth.value = displayWidth * dpr;
                        canvasHeight.value = displayHeight * dpr;

                        // Set canvas display size via CSS
                        canvasRef.value.style.width = `${displayWidth}px`;
                        canvasRef.value.style.height = `${displayHeight}px`;

                        // Wait for Vue to update the canvas element before rendering
                        nextTick(() => {
                            render();
                        });
                    };

                    updateCanvasSize();

                    // Resize observer
                    new ResizeObserver(() => {
                        updateCanvasSize();
                    }).observe(container);

                    window.addEventListener("keydown", handleKeydown);

                    loadFromLocalStorage();
                    loadLoadSheetFromStorage();
                    render();
                });

                onUnmounted(() => {
                    window.removeEventListener("keydown", handleKeydown);
                });

                return {
                    canvasRef,
                    mode,
                    tools,
                    setTool,
                    nodes,
                    edges,

                    // Selection State
                    selectedNodes,
                    selectedEdges,
                    singleSelectedNode,
                    singleSelectedEdge,
                    selectionBox,
                    isDraggingSelection,

                    // Image State & Functions
                    backgroundImage,
                    isImageSelected,
                    handleImageUpload,
                    triggerImageUpload,
                    deleteImage,

                    // Duct Sizing Suggestion
                    targetHeadLoss,
                    calculateDuctDimension,

                    deleteSelected,
                    history,
                    defaultCfm,
                    undo,
                    clearAll,
                    recalcAndRender,
                    updateMouse,
                    handleCanvasClick,
                    canvasWidth,
                    canvasHeight,
                    handleMouseUp,
                    handleWheel,
                    resetView,
                    snapToGrid,
                    mouseWorld,
                    draggingNode,
                    deleteSelected,
                    exportJSON,
                    importJSON,
                    triggerImport,
                    loadSheet,
                    loadSheetColumns,
                    loadSheetStatus,

                    // Bulk CFM Editor
                    allSelectedAreTerminals,
                    bulkCfm,
                    applyBulkCfm,

                    isScheduleExpanded,
                    triggerLoadSheetUpload,
                    handleLoadSheetUpload,
                    clearLoadSheet,
                    showLoadSheetDialog,
                    editingEntry,
                    editCfm,
                    editSize,
                    openAddEntry,
                    openEditEntry,
                    saveEntry,
                    deleteEntry,
                };
            },
        }).mount("#app");
    </script>
</body>

</html>